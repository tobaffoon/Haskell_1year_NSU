<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
 <title>L1: Введение в декларативное и функциональное программирование</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h2>Введение в декларативное и функциональное программирование</h2>
<p>Какие бывают виды программирования??? :)</p>
<h3>Что такое императивное программирование?</h3>
<p>Обычно императивное программирование — это инструкции, описывающее на том или ином уровне детализации, <strong>как</strong> решить задачу и представить результат.</p>
<p><a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BC%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" class="uri" title="Императивное_программирование">https://ru.wikipedia.org/wiki/Императивное_программирование</a></p>
<p>Основные черты императивных языков:</p>
<ul>
<li>использование именованных переменных;</li>
<li>использование оператора присваивания;</li>
<li>использование составных выражений;</li>
<li>использование подпрограмм.</li>
</ul>
<p>более подробно:</p>
<ul>
<li>в исходном коде программы записываются инструкции (команды);</li>
<li>инструкции должны выполняться (как правило) последовательно;</li>
<li>при выполнении инструкции данные, полученные при выполнении предыдущих инструкций, могут читаться из памяти;</li>
<li>данные, полученные при выполнении инструкции, могут записываться в память.</li>
</ul>
<p>Императивная программа похожа на приказы (англ. imperative — приказ, повелительное наклонение), выражаемые повелительным наклонением в естественных языках, т.е. представляют собой последовательность команд, которые должен выполнить компьютер.</p>
<h4>Структура архитектуры фон Неймана</h4>
<p>В простейшей форме характеризуется тремя составными частями: центральным процессором, памятью и соединительной шиной, которая за 1 шаг может передавать только одно слово и посылать некий адрес в память… Задача программы состоит в том, чтобы как-то изменить содержимое памяти.</p>
<p>Отвлечемся пока от критики архитектуры, на которой основаны практически все существующие вычислительные устройства.</p>
<h4>Традиционные языки программирования</h4>
<ul>
<li>машинный код;</li>
<li>ассемблер;</li>
<li>Fortran, Algol, Basic;</li>
<li>Pascal, C, Perl;</li>
<li>Python, Java, C++.</li>
</ul>
<p>Обычно, современные языки являются высокоуровневыми. Но даже наличие разнообразных нововведений вроде ООП мало меняет ситуацию — они по сути сложные версии машины фон Неймана, т.е. <em>императивные</em> или как ещё говорят, <em>процедурные</em>.</p>
<h4>Вывод</h4>
<p>Несмотря на все свою интеллектуальную привлекательность программирование является трудным занятием. После сорока лет многие перестают программировать под предлогом, что устали. Основной причиной такого положения является субъективное чувство «нарушения энергетического баланса» — много тратят, но мало получают. Программисты тратят много лет и усилий, чтобы научиться программировать в императивном (процедурном) стиле. Но императивный стиль программирования — стиль, в котором выполняются программы на компьютере — совершенно не свойственен человеческой природе. Традиционное процедурное программирование приучают программиста мыслить понятиями «машины фон Неймана», а не математическими понятиями. Традиционный программист — по своим знаниям, в первую очередь, должен быть инженером.</p>
<p>Процедурное программирование наиболее пригодно для решения задач, в которых последовательное исполнение каких-либо команд является естественным. Примером здесь может служить управление современными аппаратными средствами. Поскольку практически все современные компьютеры императивны, эта методология позволяет порождать достаточно эффективный исполняемый код. С ростом сложности задачи процедурные программы становятся все менее и менее читаемыми. Программирование и отладка действительно больших программ (например, компиляторов), написанных исключительно на основе методологии императивного программирования, может затянуться на долгие годы.</p>
<blockquote>
<p>«Я с лёгкостью сделаю на C++ за месяц то, что вы с трудом напишите на Lisp за неделю…»</p>
</blockquote>
<!-- Зюзысов С.5 -->

<h3>Декларативное программирование</h3>
<!-- [http://www.softcraft.ru/paradigm/dp/dp01/](http://www.softcraft.ru/paradigm/dp/dp01/ Дехтяренко. Программирование в повествовательном наклонении) -->

<p><a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BB%D0%B0%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" class="uri" title="Декларативное_программирование">https://ru.wikipedia.org/wiki/Декларативное_программирование</a></p>
<p>Парадигма программирования, в которой задаётся спецификация решения задачи, т.е. описывается, <strong>что</strong> представляет собой проблема и ожидаемый результат.</p>
<p>Декларативное программирование стремится описывать саму задачу в терминах, во-первых, самой задачи, а во-вторых, математики, логики и, возможно когда-либо, на естественном языке (а в настоящее время на вариантах DSL).</p>
<p><a href="https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" class="uri" title="Языково-ориентированное_программирование (DSL)">https://ru.wikipedia.org/wiki/Языково-ориентированное_программирование</a></p>
<p>В идеале, составляется точная спецификация задачи, а машина затем «думает» как решать задачу и сама её решает.</p>
<p>На практике же мы можем указать два базовых направления декларативного программирования: логическое и функциональное.</p>
<h3>Логическое программирование</h3>
<p>Парадигма программирования, основанная на автоматическом доказательстве теорем. Логическое программирование основано на теории и аппарате математической логики с использованием математических принципов резолюций. Самым известным языком логического программирования является Prolog.</p>
<p>…</p>
<!-- Зюзысов С.42 -->

<p>Используется язык исчисления логики предикатов первого порядка. Предполагалось, что программист не указывает последовательность шагов решения, а на логическом языке описывал бы свойства интересующей его области. Далее, исполняющая система пыталась бы найти решение сама.</p>
<p>Несмотря на использование ряда интересных идей (и на взрыв интереса к языку Prolog в конце 80-х гг. прошлого века из-за объявления японцами Prolog’а языком для своих (супер?)компьютеров 5-го поколения), по сути вычисления на языке Prolog остались переборными и в большинстве практических задач малоэффективными.</p>
<h4>Факт</h4>
<p>Развитие логического и семантического программирования в новосибирском академгородке с начала 80-х гг. и до сих пор.</p>
<h3>SQL</h3>
<p>Ещё одним примером декларативного программирования является «информационно-логический язык» (в другом представлении — DSL) SQL, предназначенный для работы с данными, хранимыми в реляционных базах данных. Этот язык не является тьюринг-полным, но это декларативный язык программирования, не детализирующий как именно следует выполнять запросы, что ложится уже на плечи СУБД.</p>
<p><a href="https://en.wikipedia.org/wiki/SQL" class="uri" title="SQL">https://en.wikipedia.org/wiki/SQL</a></p>
<h3>Функциональное программирование</h3>
<!-- (может, уровень 2 ??) -->  

<p>Парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании).</p>
<h4>Разница в понимании функций в функциональном и в императивном программировании</h4>
<p>Рассмотрим следующую программу на языке JavaScript:</p>
<pre><code>function f(n) {
  if (flag) {
      flag = !flag; return(n)
  } else {
      flag = !flag; return(2*n)
  }
}

var flag = true;

console.log( f(1)+f(2) );
console.log( f(2)+f(1) );
</code></pre>
<p>при исполнении в консоли увидим следующие ответы:</p>
<pre><code>5
4
</code></pre>
<p>хотя, казалось бы, на первый взгляд, мы могли бы ожидать коммутативности сложения! Разумеется, дело не в изменении свойств операции «+» в JavaScript, просто, так называемая функция <code>f</code> в своём коде помимо аргумента использовала значение глобальной переменной <code>flag</code>. Такие функции мы будем назвать «нечистыми», или <em>функциями с побочными эффектами</em>.</p>
<p>Отметим, что в данном случае, ещё одним источником проблемы стал оператор присваивания «=» в JavaScript (или «:=» в Pascal).</p>
<p>Аналог примера на Pascal:</p>
<pre><code>program ex1(output);
var flag: boolean;

function f(n: integer): integer;
begin
  if flag then f:=n
          else f:=2*n;
  flag := not flag;
end;

begin
  flag := true;
  writeln( f(1)+f(2) );
  writeln( f(2)+f(1) );
end.
</code></pre>
<p>В целом, такие ситуации называются <em>побочными эффектами</em>.</p>
<p><a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B1%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D1%8D%D1%84%D1%84%D0%B5%D0%BA%D1%82_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29" class="uri" title="Побочный_эффект_(программирование)">https://ru.wikipedia.org/wiki/Побочный_эффект_(программирование)</a></p>
<p>Точнее, побочными эффектами обычно называют возможность функций в процессе выполнения своих вычислений читать и модифицировать значения глобальных переменных, осуществлять операции ввода-вывода, реагировать на исключительные ситуации и т.п. При вторичном вызове подобной функции (с одними и теми же входными аргументами) мы можем обнаружить, что в результате будут возвращены разные значения.</p>
<p>Побочные эффекты не являются чем-то слишком необычным. В императивных языках они встречаются чаще (можно сказать повсеместно), в декларативных и функциональных языках — минимальным образом. Но они все-таки необходимы и в последних. В первую очередь это относится именно к вводу-выводу. Кроме того, некоторые алгоритмы являются более естественными или эффективными и понятными (особенно при портировании их из императивных языков) при наличии присваивания и глобальных переменных.</p>
<p>Но, в общем, функциональное (и декларативное в целом) программирование радикально отличается от императивного программирования именно тем, что по сути функциональная программа представляет собой чистую математическую функцию, зависящую строго от своих аргументов, а выполнением программы становится вычисление для конкретных аргументов (или <em>аппликация</em>, т.е. применение, поэтому иногда говорят об <em>аппликативном программировании</em>).</p>
<p>Поэтому, обычно, в чисто функциональных языках программирования нет глобальных переменных, нет оператора присваивания, или их действия носят строго ограниченный характер.</p>
<p>Давайте глянем на простой пример, который может показать разницу подходов при решении типовой задачи в императивном и функциональном программировании.</p>
<p>Например, мы хотим вычислить сумму кубов целых чисел от 1 до 100.</p>
<p>На языке Pascal это будет выглядеть примерно так: …</p>
<p>На JavaScript:</p>
<pre><code>function f(x){ 
  return (Math.pow(x,3))
};

sum = 0;
for (i=1;i&lt;=100;i++) {
  sum += f(i)
};
console.log(&quot;sum=&quot; ++ sum);
</code></pre>
<p>На Haskell:</p>
<pre><code>print $ sum $ map (^3) [1..100]
</code></pre>
<p>Разница в том, что для императивного языка мы явно задаем что и как делать, а для декларативного — просто пользуемся описательными методами.</p>
<p>К слову, на многих современных языках программирования, на том же JavaScript, есть возможность воспользоваться <code>map</code>:</p>
<pre><code>function f(x){ 
  return (Math.pow(x,3))
};

var arr = [1,2,3,4,5,6,7,8,9,10];
console.log(arr.map(f));     
</code></pre>
<p>если только получить список кубов, а вот полное решение с использованием ещё и метода <code>reduce</code>:</p>
<pre><code>function f(x){ 
  return (Math.pow(x,3))
};

var arr = [1,2,3,4,5,6,7,8,9,10];
console.log( (arr.map(f)).reduce(function(sum,current){
  return sum + current}) );  
</code></pre>
<p>Вот ещё вариант решения на Haskell:</p>
<pre><code>print $ sum [x^3 | x &lt;- [1..100]]
</code></pre>
<p>Правая часть записи абсолютно и неслучайно похожа на математическую нотацию:</p>
<p>{ <i>x</i><sup>3</sup> | <i>x</i> ∈ {1,…,100} }.</p>
</body>
</html>
